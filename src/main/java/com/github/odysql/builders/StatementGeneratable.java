package com.github.odysql.builders;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;

import com.github.odysql.helpers.PreparedStatementFiller;
import com.github.odysql.models.SQLParameter;

/** Interface that support get prepared statement from builder. */
interface StatementGeneratable {

    /**
     * Get ordered parameters list, which is the values that will be put into
     * statement with '?' character.
     * 
     * @return list of parameters, its order is same as sql string creation order.
     */
    public List<SQLParameter> getParams();

    /**
     * Get the sql. Developer should create a PreparedStatement by this result to
     * prevent Injection.
     * <p>
     * After generated a prepared statement, developers can use
     * <code>fillStatement</code> to fill the designed parameter (? character).
     * 
     * @return SQL string, with ? character for reserve space for actual value
     */
    public String toSQL();

    /**
     * Fill the Prepared Statement with the value that already store in the builder.
     * <p>
     * This method is aim to ensure no more counting index for e.g.
     * <code>stmt.setString(int, String)</code>, the index increment and handle will
     * be completed by the builder itself.
     * 
     * @param statement the generated Prepared Statement, which should be get from
     *                  <code>Connection.prepareStatement</code>.
     * @return Prepared Statement, which all designated parameter is set.
     * @throws SQLException when it is unable to assign value to designated
     *                      parameter.
     */
    public default PreparedStatement fillStatement(PreparedStatement statement) throws SQLException {
        int index = 0;

        // Fill variable with param list
        for (SQLParameter param : this.getParams()) {
            // Index is start from 1
            index++;

            // Handle parameter with designed type
            statement = param.apply(statement, index);
        }

        return statement;
    }

    /**
     * Get a filled Prepared Statement with the value that already store in the
     * builder, with {@link com.github.odysql.builders.StatementGeneratable#toSQL()}
     * used as SQL.
     * <p>
     * This method is designed to use in try-with-resources, as a short-cut method
     * for {@link #fillStatement(PreparedStatement)}
     * 
     * @param conn Connection to database
     * @return Prepared Statement, which all designated parameter is set.
     * @throws SQLException when it is unable to assign value to designated
     *                      parameter.
     * @see #prepare(DataServiceable)
     */
    public default PreparedStatement prepare(Connection conn) throws SQLException {
        PreparedStatement stmt = conn.prepareStatement(this.toSQL());
        return this.fillStatement(stmt);
    }

    /**
     * Get a filled Prepared Statement with the value that already store in the
     * builder, with{@link com.github.odysql.builders.StatementGeneratable#toSQL()}
     * used as SQL.
     * <p>
     * This method is designed to use in try-with-resources, as a short-cut method
     * for {@link #fillStatement(PreparedStatement)}.
     * <p>
     * Please note that this function provide functionality similar to
     * {@link Connection#prepareStatement(String, int)}.
     * 
     * @param conn              Connection to database
     * @param autoGeneratedKeys a flag indicating whether auto-generated keys should
     *                          be returned; one of Statement.RETURN_GENERATED_KEYS
     *                          or Statement.NO_GENERATED_KEYS
     * @return Prepared Statement, which all designated parameter is set.
     * @throws SQLException when it is unable to assign value to designated
     *                      parameter.
     * @see Connection#prepareStatement(String, int)
     */
    public default PreparedStatement prepare(Connection conn, int autoGeneratedKeys) throws SQLException {
        PreparedStatement stmt = conn.prepareStatement(this.toSQL(), autoGeneratedKeys);
        return this.fillStatement(stmt);
    }

    /**
     * Get SQL for debugging, which is not for prepared statement.
     * <p>
     * Please note that this method is only for debugging purpose, the SQL returned
     * may not able to generate SQL that runnable in all SQL server, as date format
     * may be different.
     * <p>
     * The returned SQL will able to run in some MariaDB server when it contains
     * <code>DATE</code> &amp; <code>DATETIME</code> values, BUT NOT GUARANTEED.
     * Developer SHOULD always use PreparedStatement when possible.
     * <p>
     * Please note that all SQL <code>DATETIME</code> will use
     * <code>yyyy-MM-dd HH:mm:ss</code> as date time format, while <code>DATE</code>
     * use <code>yyyy-MM-dd</code> as date format.
     * 
     * @return complete SQL statement that not contain "?" character
     */
    public default String getDebugSQL() {
        return PreparedStatementFiller.asDebugSQL(this.toSQL(), this.getParams());
    }
}
